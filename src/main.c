/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "gpio.h"
#include "rcc.h"
#include "uart.h"
#include "adc.h"
#include "spi.h"
#include "reset_function.h"
#include "iperipheral.h"
#include <string.h>


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


void enable_clock()
{
    *RCC_CR |= HSI_ON;
    while (HSI_RDY != 2);

    *RCC_CFGR |= HSI_SYSCLK;
    while ((*RCC_CFGR & SYSCLK_RDY_FLAG) != 0);

    *RCC_CFGR |= AHB_CLK_NOT_DIVIDE;
    *RCC_CFGR |= APB1_CLK_NOT_DIVIDE;
    *RCC_CFGR |= APB2_CLK_NOT_DIVIDE;

    *RCC_CFGR &= ~(11<<14);

    *RCC_APB2ENR |= PORTA_EN | AFIO_EN | UART1_EN | (1u<<9);
}

void pin_initialize()
{
	// tx pa9 rx pa10
	*GPIOA_CRH |= GPIO_CNF_OUTPUT_AF_PP<<CNF9 | GPIO_MODE_OUTPUT_10MHZ <<MODE9;
	*GPIOA_CRH |= GPIO_CNF_INPUT_FLOATING<<CNF10 | GPIO_MODE_INPUT<<MODE10;
	// GPIOA 0-7 ADC channel input analog
	*GPIOA_CRL |= GPIO_MODE_INPUT<<MODE0 | GPIO_CNF_INPUT_ANALOG<<CNF0;
	*GPIOA_CRL |= GPIO_MODE_INPUT<<MODE1 | GPIO_CNF_INPUT_ANALOG<<CNF1;
	*GPIOA_CRL |= GPIO_MODE_INPUT<<MODE2 | GPIO_CNF_INPUT_ANALOG<<CNF2;
	*GPIOA_CRL |= GPIO_MODE_INPUT<<MODE3 | GPIO_CNF_INPUT_ANALOG<<CNF3;
	*GPIOA_CRL |= GPIO_MODE_INPUT<<MODE4 | GPIO_CNF_INPUT_ANALOG<<CNF4;
	*GPIOA_CRL |= GPIO_MODE_INPUT<<MODE5 | GPIO_CNF_INPUT_ANALOG<<CNF5;
	*GPIOA_CRL |= GPIO_MODE_INPUT<<MODE6 | GPIO_CNF_INPUT_ANALOG<<CNF6;
	*GPIOA_CRL |= GPIO_MODE_INPUT<<MODE7 | GPIO_CNF_INPUT_ANALOG<<CNF7;
	*AFIO_MAPR = 0;
}

uint8_t UART_Check_Errors(void) {
    uint8_t error_code = 0;

    // 1. Kiểm tra lỗi Overrun (Dữ liệu mới đè lên dữ liệu cũ chưa kịp đọc)
    if (ORE) {
        // Cách xóa ORE: Đọc thanh ghi SR rồi đọc thanh ghi DR
        error_code |= (1 << 3);
        printf("Error: Overrun Error (ORE) detected!\r\n");
    }

    // 2. Kiểm tra lỗi Noise (Nhiễu tín hiệu trên đường truyền)
    if (NE) {
        error_code |= (1 << 2);
        printf("Error: Noise Error (NE) detected!\r\n");
    }

    // 3. Kiểm tra lỗi Framing (Sai cấu trúc khung truyền - ví dụ sai Stop bit)
    if (FE) {
        error_code |= (1 << 1);
        printf("Error: Framing Error (FE) detected!\r\n");
    }

    // 4. Kiểm tra lỗi Parity (Sai bit kiểm tra chẵn lẻ)
    if (PE) {
        error_code |= (1 << 0);
        printf("Error: Parity Error (PE) detected!\r\n");
    }

    // Lưu ý quan trọng từ tài liệu RM0008:
    // Để xóa các cờ lỗi này (FE, NE, ORE, PE), quy trình thường là:
    // Bước 1: Đọc thanh ghi USART_SR (đã thực hiện qua các macro của bạn)
    // Bước 2: Đọc thanh ghi USART_DR
    if (error_code != 0) {
        volatile uint32_t dummy = *USART_DR; // Đọc giả để xóa cờ lỗi
        (void)dummy; // Tránh cảnh báo biến không sử dụng
    }

    return error_code;
}

void server_transmit(uint8_t* data)
{
	uint8_t size = 8;
	for (int i = 0; i < size; i++)
	{
		uart_transmit(data[i]);
		if (UART_Check_Errors() == 0) {
		        // Nếu không có lỗi và có dữ liệu mới (RXNE)
		        if (RXNE)
		        {
		            uint8_t rx = *USART_DR;
		            // Xử lý dữ liệu...
		            *USART_SR &= ~(1u<<5);
		        }
		    } else {
		    	uart_transmit(data[i]);
		    }
		if (i == (size - 1))
		{
			while (!TC);
		}
	}
}

void sys_start()
{
	ADC_Start();
}

void initialize()
{
	pin_initialize();
	uart_init(115200, eight_data_bits, 1);
	ADC_init();
	*USART_CR1 &= ~(1u<<10);
}

int main(void)
{
    /* Loop forever */
	reset_sys();
	enable_clock();
	initialize();
	sys_start();
	while (1)
	{
		uint8_t adc_data[8];
		for (int i = 0; i < 8; i++)
		{
			adc_data[i] = 0;
		}
		ADC_Read_8Channels(adc_data);
		server_transmit(adc_data);
		delay_ms(500);
	}
}
